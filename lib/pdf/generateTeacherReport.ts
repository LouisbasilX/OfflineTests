import { jsPDF } from 'jspdf'
import autoTable from 'jspdf-autotable'

interface TeacherReportData {
  testTitle: string
  submissions: Array<{
    studentName: string
    score: number
    maxScore: number
    percentage: number
    grade: string
    submittedAt: string
    suspicious: boolean
    timeLogs?: any
  }>
  questionStats: Array<{
    questionNumber: number
    averageScore: number
    maxScore: number
    difficulty: string
  }>
  teacherNotes?: string
  metadata?: {
    testCode?: string
    duration?: number
    totalQuestions?: number
    createdAt?: string
  }
}

export async function generateTeacherReport(data: TeacherReportData): Promise<Blob> {
  const doc = new jsPDF()
  
  // Add logo/title
  doc.setFontSize(20)
  doc.setTextColor(56, 189, 248) // Accent color
  doc.text('Class Performance Report', 105, 20, { align: 'center' })
  
  // Test info
  doc.setFontSize(12)
  doc.setTextColor(0, 0, 0)
  doc.text(`Test: ${data.testTitle}`, 20, 40)
  doc.text(`Date: ${new Date().toLocaleDateString()}`, 20, 50)
  if (data.metadata?.testCode) {
    doc.text(`Test Code: ${data.metadata.testCode}`, 20, 60)
  }
  
  // Summary statistics
  const avgScore = data.submissions.reduce((sum, s) => sum + s.score, 0) / data.submissions.length
  const avgPercentage = data.submissions.reduce((sum, s) => sum + s.percentage, 0) / data.submissions.length
  const suspiciousCount = data.submissions.filter(s => s.suspicious).length
  
  autoTable(doc, {
    startY: 70,
    head: [['Metric', 'Value']],
    body: [
      ['Total Students', data.submissions.length.toString()],
      ['Average Score', `${avgScore.toFixed(1)}/${data.submissions[0]?.maxScore || 100}`],
      ['Average Percentage', `${avgPercentage.toFixed(1)}%`],
      ['Highest Score', Math.max(...data.submissions.map(s => s.score)).toString()],
      ['Lowest Score', Math.min(...data.submissions.map(s => s.score)).toString()],
      ['Suspicious Submissions', suspiciousCount.toString()],
      ['Submission Rate', '100%'] // Assuming all students submitted
    ],
    theme: 'grid',
    headStyles: { fillColor: [56, 189, 248] },
  })
  
  // Student scores table
  autoTable(doc, {
    startY: (doc as any).lastAutoTable.finalY + 10,
    head: [['Student', 'Score', 'Percentage', 'Grade', 'Status', 'Submitted']],
    body: data.submissions.map(s => [
      s.studentName,
      `${s.score}/${s.maxScore}`,
      `${s.percentage}%`,
      s.grade,
      s.suspicious ? '⚠ Review' : '✓ Normal',
      new Date(s.submittedAt).toLocaleDateString()
    ]),
    theme: 'grid',
    headStyles: { fillColor: [56, 189, 248] },
    columnStyles: {
      4: { cellWidth: 25 }, // Status column
      5: { cellWidth: 30 }  // Submitted column
    }
  })
  
  // Question analysis
  autoTable(doc, {
    startY: (doc as any).lastAutoTable.finalY + 10,
    head: [['Question', 'Average Score', 'Max Score', 'Difficulty', 'Success Rate']],
    body: data.questionStats.map(q => [
      `Q${q.questionNumber}`,
      q.averageScore.toFixed(1),
      q.maxScore.toString(),
      q.difficulty,
      `${((q.averageScore / q.maxScore) * 100).toFixed(1)}%`
    ]),
    theme: 'grid',
    headStyles: { fillColor: [56, 189, 248] },
  })
  
  // Grade distribution
  const gradeDistribution = data.submissions.reduce((acc: Record<string, number>, s) => {
    acc[s.grade] = (acc[s.grade] || 0) + 1
    return acc
  }, {})
  
  autoTable(doc, {
    startY: (doc as any).lastAutoTable.finalY + 10,
    head: [['Grade', 'Students', 'Percentage']],
    body: Object.entries(gradeDistribution).map(([grade, count]) => [
      grade,
      count.toString(),
      `${((count / data.submissions.length) * 100).toFixed(1)}%`
    ]),
    theme: 'grid',
    headStyles: { fillColor: [56, 189, 248] },
  })
  
  // Teacher notes
  if (data.teacherNotes) {
    doc.setFontSize(11)
    doc.text('Teacher Notes:', 20, (doc as any).lastAutoTable.finalY + 20)
    doc.setFontSize(10)
    const splitNotes = doc.splitTextToSize(data.teacherNotes, 170)
    doc.text(splitNotes, 20, (doc as any).lastAutoTable.finalY + 30)
  }
  
  // Footer on all pages
  const pageCount = doc.getNumberOfPages()
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i)
    doc.setFontSize(8)
    doc.setTextColor(128, 128, 128)
    doc.text(
      `Page ${i} of ${pageCount} • Generated by OfflineTests • Confidential`,
      105,
      doc.internal.pageSize.height - 10,
      { align: 'center' }
    )
    doc.text(
      `Data encrypted • Automatic expiration • ${new Date().toLocaleString()}`,
      105,
      doc.internal.pageSize.height - 5,
      { align: 'center' }
    )
  }
  
  // Convert to blob
  const pdfBlob = doc.output('blob')
  return pdfBlob
}

export function downloadTeacherReport(data: TeacherReportData, filename?: string) {
  generateTeacherReport(data).then(blob => {
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = filename || `Teacher_Report_${data.testTitle.replace(/\s+/g, '_')}.pdf`
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  })
}

export function getReportStatistics(data: TeacherReportData) {
  const scores = data.submissions.map(s => s.score)
  const maxScore = data.submissions[0]?.maxScore || 100
  
  return {
    mean: scores.reduce((a, b) => a + b, 0) / scores.length,
    median: scores.sort((a, b) => a - b)[Math.floor(scores.length / 2)],
    mode: getMode(scores),
    standardDeviation: getStandardDeviation(scores),
    passRate: (scores.filter(s => (s / maxScore) * 100 >= 60).length / scores.length) * 100,
    gradeDistribution: data.submissions.reduce((acc: Record<string, number>, s) => {
      acc[s.grade] = (acc[s.grade] || 0) + 1
      return acc
    }, {}),
    questionDifficulty: data.questionStats.reduce((acc: Record<string, number>, q) => {
      acc[q.difficulty] = (acc[q.difficulty] || 0) + 1
      return acc
    }, {})
  }
}

function getMode(arr: number[]): number {
  const frequency: Record<number, number> = {}
  let maxFreq = 0
  let mode = arr[0]
  
  arr.forEach(num => {
    frequency[num] = (frequency[num] || 0) + 1
    if (frequency[num] > maxFreq) {
      maxFreq = frequency[num]
      mode = num
    }
  })
  
  return mode
}

function getStandardDeviation(arr: number[]): number {
  const mean = arr.reduce((a, b) => a + b, 0) / arr.length
  const squareDiffs = arr.map(value => Math.pow(value - mean, 2))
  const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length
  return Math.sqrt(avgSquareDiff)
}